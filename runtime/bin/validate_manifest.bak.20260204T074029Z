#!/usr/bin/env python3
import argparse, json, os, re, sys

HEX64 = re.compile(r"^[a-f0-9]{64}$")
REL_SAFE = re.compile(r"^[A-Za-z0-9._-]+$")  # basename-only, no slashes

def fail(msg: str) -> int:
    print(f"INVALID: {msg}", file=sys.stderr)
    return 1

def ok(msg: str="OK") -> int:
    print(msg)
    return 0

def is_relative_sibling_path(p: str) -> bool:
    # Strict: basename only (no dirs), prevents arbitrary paths.
    return bool(REL_SAFE.match(p))

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--manifest", required=True)
    args = ap.parse_args()

    mpath = args.manifest
    if not os.path.isfile(mpath):
        return fail(f"manifest not found: {mpath}")

    try:
        with open(mpath, "r", encoding="utf-8") as f:
            m = json.load(f)
    except Exception as e:
        return fail(f"manifest not valid json: {e}")

    # Baseline invariants (minimal, stable)
    for k in ("release_id", "bundle_path", "bundle_sha256"):
        if k not in m:
            return fail(f"missing required field: {k}")
    if not isinstance(m["release_id"], str) or not m["release_id"].strip():
        return fail("release_id must be non-empty string")
    if not isinstance(m["bundle_path"], str) or not m["bundle_path"].strip():
        return fail("bundle_path must be non-empty string")
    if not isinstance(m["bundle_sha256"], str) or not HEX64.match(m["bundle_sha256"]):
        return fail("bundle_sha256 must be 64-char lowercase hex")

    # Phase 98 signing invariants (policy-driven)
    signing_fields = (
        "signing_alg",
        "signing_pub_fingerprint_sha256",
        "manifest_sig_b64_path",
        "bundle_sig_b64_path",
    )
    present = [k for k in signing_fields if k in m and m[k] is not None]

    if present and len(present) != len(signing_fields):
        missing = [k for k in signing_fields if k not in m or m[k] is None]
        return fail(f"partial signing metadata: missing {','.join(missing)}")

    if len(present) == len(signing_fields):
        # Alg
        if m["signing_alg"] != "rsa-sha256-b64":
            return fail("signing_alg must be rsa-sha256-b64")

        # Fingerprint
        fp = m["signing_pub_fingerprint_sha256"]
        if not isinstance(fp, str) or not HEX64.match(fp):
            return fail("signing_pub_fingerprint_sha256 must be 64-char lowercase hex")

        # Paths must be safe siblings (no arbitrary paths)
        man_sig = m["manifest_sig_b64_path"]
        bun_sig = m["bundle_sig_b64_path"]
        if not isinstance(man_sig, str) or not is_relative_sibling_path(man_sig):
            return fail("manifest_sig_b64_path must be a safe sibling basename")
        if not isinstance(bun_sig, str) or not is_relative_sibling_path(bun_sig):
            return fail("bundle_sig_b64_path must be a safe sibling basename")

        # Strong naming expectations: signatures should look like siblings of targets
        # (We don't assume exact bundle filename, but enforce .sig.b64 suffix.)
        if not man_sig.endswith(".sig.b64"):
            return fail("manifest_sig_b64_path must end with .sig.b64")
        if not bun_sig.endswith(".sig.b64"):
            return fail("bundle_sig_b64_path must end with .sig.b64")

        # Optional existence check (strict-but-local): if signature paths declared, they should exist.
        # They are expected to be siblings of the manifest file.
        mdir = os.path.dirname(os.path.abspath(mpath))
        if not os.path.isfile(os.path.join(mdir, man_sig)):
            return fail(f"declared manifest signature missing: {man_sig}")
        if not os.path.isfile(os.path.join(mdir, bun_sig)):
            return fail(f"declared bundle signature missing: {bun_sig}")

    return ok("VALID")

if __name__ == "__main__":
    raise SystemExit(main())
