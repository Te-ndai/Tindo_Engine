#!/usr/bin/env bash
# test/84_test_restore_replay.sh
# Phase 84 TEST: Restore + replay proof for release bundle
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"

# ---------- helpers ----------
die() { echo "❌ $*" 1>&2; exit 1; }

require_file() { [ -f "$1" ] || die "missing file: $1"; }
require_dir() { [ -d "$1" ] || die "missing dir: $1"; }

# Locate the newest release bundle.
# Expected: releases/*.tar.gz and a corresponding manifest json alongside or inside.
# If your Phase 83 wrote a different location, adjust RELEASE_GLOB only.
RELEASE_GLOB="runtime/state/releases/release_*.tar.gz"

# shellcheck disable=SC2086
LATEST_TARBALL="$(ls -1t $RELEASE_GLOB 2>/dev/null | head -n 1 || true)"
[ -n "$LATEST_TARBALL" ] || die "no release tarball found at: $RELEASE_GLOB"

echo "Using release tarball: $LATEST_TARBALL"

# Create clean restore dir
RESTORE_DIR="$(mktemp -d)"
cleanup() { rm -rf "$RESTORE_DIR"; }
trap cleanup EXIT

# Unpack
tar -xzf "$LATEST_TARBALL" -C "$RESTORE_DIR"

# Heuristic: bundle root should contain runtime/ and a manifest json.
# Try common names/locations inside restored bundle.
MANIFEST_PATH=""
for cand in \
  "$RESTORE_DIR/release.manifest.json" \
  "$RESTORE_DIR/manifest.json" \
  "$RESTORE_DIR/runtime.manifest.json" \
  "$RESTORE_DIR/runtime/state/releases/release.manifest.json" \
  "$RESTORE_DIR/runtime/state/releases/manifest.json"
do
  if [ -f "$cand" ]; then MANIFEST_PATH="$cand"; break; fi
done

# If still not found, pick the newest release_*.json anywhere under restore dir.
if [ -z "$MANIFEST_PATH" ]; then
  MANIFEST_PATH="$(find "$RESTORE_DIR" -type f -name 'release_*.json' 2>/dev/null | sort | tail -n 1 || true)"
fi

[ -n "$MANIFEST_PATH" ] || die "could not find manifest json in restored bundle"
echo "Found manifest: $MANIFEST_PATH"


# Must contain runtime/
require_dir "$RESTORE_DIR/runtime"
require_dir "$RESTORE_DIR/runtime/bin"
# Make entrypoint executable just in case tar preserved perms poorly
# ---------- read expectations from manifest ----------
# We only assert what we can robustly find. This avoids brittle coupling.
# Expected fields (recommended):
# - expected_event_count
# - expected_last_event_time_utc
# If absent, we assert integrity + that replay produces non-empty projections/reports.

python3 - <<'PY' "$MANIFEST_PATH" > "$RESTORE_DIR/_expected.json"
import json, sys
p = sys.argv[1]
m = json.load(open(p, "r", encoding="utf-8"))

def pick(*keys):
    cur = m
    for k in keys:
        if isinstance(cur, dict) and k in cur:
            cur = cur[k]
        else:
            return None
    return cur

out = {
  "expected_event_count": (
      m.get("expected_event_count")
      or pick("expectations","event_count")
      or pick("runtime","state","logs","event_count")
  ),
  "expected_last_event_time_utc": (
      m.get("expected_last_event_time_utc")
      or pick("expectations","last_event_time_utc")
      or pick("runtime","state","logs","last_event_time_utc")
  ),
}
print(json.dumps(out))
PY

EXPECTED_EVENT_COUNT="$(python3 -c 'import json,sys; d=json.load(open(sys.argv[1])); print("" if d.get("expected_event_count") is None else d["expected_event_count"])' "$RESTORE_DIR/_expected.json")"
EXPECTED_LAST_EVENT_TIME="$(python3 -c 'import json,sys; d=json.load(open(sys.argv[1])); print("" if d.get("expected_last_event_time_utc") is None else d["expected_last_event_time_utc"])' "$RESTORE_DIR/_expected.json")"

echo "Expected event count: ${EXPECTED_EVENT_COUNT:-<unspecified>}"
echo "Expected last_event_time_utc: ${EXPECTED_LAST_EVENT_TIME:-<unspecified>}"

# ---------- run restore verification + replay ----------
# If your runtime uses different verbs, rename them here ONLY.
BIN="$RESTORE_DIR/runtime/bin"

LOGCHAIN_VERIFY="$BIN/logchain_verify"
REBUILD_PROJECTIONS="$BIN/rebuild_projections"
OPS="$BIN/ops"

require_file "$LOGCHAIN_VERIFY"
require_file "$REBUILD_PROJECTIONS"
require_file "$OPS"

chmod +x "$LOGCHAIN_VERIFY" "$REBUILD_PROJECTIONS" "$OPS" || true
# 1) logchain_verify
echo "Running: logchain_verify"
"$LOGCHAIN_VERIFY" --root "$RESTORE_DIR/runtime" || die "logchain_verify failed"

# 2) rebuild_projections
echo "Running: rebuild_projections"
REBUILD_OUT="$RESTORE_DIR/_rebuild_projections.out"
REBUILD_ERR="$RESTORE_DIR/_rebuild_projections.err"
set +e
"$REBUILD_PROJECTIONS" --root "$RESTORE_DIR/runtime" >"$REBUILD_OUT" 2>"$REBUILD_ERR"
rc=$?
set -e
if [ "$rc" -ne 0 ]; then
  echo "❌ rebuild_projections failed (exit=$rc)"
  echo "---- stdout ----"
  sed -n '1,200p' "$REBUILD_OUT" || true
  echo "---- stderr ----"
  sed -n '1,200p' "$REBUILD_ERR" || true
  echo "---- rebuild_projections --help ----"
  "$REBUILD_PROJECTIONS" --help 2>&1 | sed -n '1,120p' || true
  echo "---- restore tree (first 120) ----"
  (cd "$RESTORE_DIR" && find . -maxdepth 4 -type f | sed -n '1,120p') || true
  exit 1
fi
# 3) ops report
echo "Running: ops report"
OPS_JSON="$RESTORE_DIR/_ops_report.json"
"$OPS" report --root "$RESTORE_DIR/runtime" --format json > "$OPS_JSON" || die "ops report failed"
[ -s "$OPS_JSON" ] || die "ops report produced empty output"

# ---------- assert results ----------
# Parse ops report for actuals. We look for obvious keys:
# - event_count
# - last_event_time_utc
python3 - <<'PY' "$OPS_JSON" > "$RESTORE_DIR/_actual.json"
import json, sys

o = json.load(open(sys.argv[1], "r", encoding="utf-8"))

def find_key(obj, targets):
    if isinstance(obj, dict):
        for k,v in obj.items():
            if k in targets:
                return v
        for v in obj.values():
            r = find_key(v, targets)
            if r is not None: return r
    elif isinstance(obj, list):
        for it in obj:
            r = find_key(it, targets)
            if r is not None: return r
    return None

out = {
  "event_count": find_key(o, {"event_count","events","log_event_count"}),
  "last_event_time_utc": find_key(o, {"last_event_time_utc","last_event_utc","last_event_time"}),
}
print(json.dumps(out))
PY

ACTUAL_EVENT_COUNT="$(python3 -c 'import json,sys; d=json.load(open(sys.argv[1])); print("" if d.get("event_count") is None else d["event_count"])' "$RESTORE_DIR/_actual.json")"
ACTUAL_LAST_EVENT_TIME="$(python3 -c 'import json,sys; d=json.load(open(sys.argv[1])); print("" if d.get("last_event_time_utc") is None else d["last_event_time_utc"])' "$RESTORE_DIR/_actual.json")"

echo "Actual event count: ${ACTUAL_EVENT_COUNT:-<unknown>}"
echo "Actual last_event_time_utc: ${ACTUAL_LAST_EVENT_TIME:-<unknown>}"

# If expected values exist, enforce equality.
if [ -n "${EXPECTED_EVENT_COUNT:-}" ]; then
  [ -n "${ACTUAL_EVENT_COUNT:-}" ] || die "manifest specifies expected_event_count but ops report did not provide event_count"
  [ "$ACTUAL_EVENT_COUNT" = "$EXPECTED_EVENT_COUNT" ] || die "event_count mismatch: expected=$EXPECTED_EVENT_COUNT actual=$ACTUAL_EVENT_COUNT"
fi

if [ -n "${EXPECTED_LAST_EVENT_TIME:-}" ]; then
  [ -n "${ACTUAL_LAST_EVENT_TIME:-}" ] || die "manifest specifies expected_last_event_time_utc but ops report did not provide last_event_time_utc"
  [ "$ACTUAL_LAST_EVENT_TIME" = "$EXPECTED_LAST_EVENT_TIME" ] || die "last_event_time_utc mismatch: expected=$EXPECTED_LAST_EVENT_TIME actual=$ACTUAL_LAST_EVENT_TIME"
fi

# Minimal operational assertions (even if manifest doesn't specify counts):
# Projections directory should exist and be non-empty after rebuild.
PROJ_DIR="$RESTORE_DIR/runtime/state/projections"
require_dir "$PROJ_DIR"
[ "$(ls -A "$PROJ_DIR" | wc -l | tr -d ' ')" -gt 0 ] || die "projections are empty after rebuild"

echo "✅ Phase 84 TEST PASS (restore + replay proof)"
