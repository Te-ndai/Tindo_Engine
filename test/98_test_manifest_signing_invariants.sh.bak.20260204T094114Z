#!/usr/bin/env bash
set -euo pipefail

# Phase 98: manifest signing invariants
# MUST NOT MINT RELEASES. Operates only on already-minted artifacts.
# Uses Phase 90 minted release and performs mutations ONLY on temp copies.

die(){ echo "ERROR: $*" >&2; exit 1; }
note(){ echo "==> $*" >&2; }

RID="${RELEASE_ID:-}"
RELEASE_DIR="runtime/state/releases"

[[ -d "$RELEASE_DIR" ]] || die "missing $RELEASE_DIR (run Phase 90 chain first)"

# Prefer RELEASE_ID if provided; else pick newest manifest.
pick_manifest() {
  if [[ -n "$RID" && -f "$RELEASE_DIR/release_${RID}.json" ]]; then
    echo "$RELEASE_DIR/release_${RID}.json"
    return 0
  fi
  ls -1t "$RELEASE_DIR"/release_*.json 2>/dev/null | head -n1
}

MANIFEST="$(pick_manifest || true)"
[[ -n "${MANIFEST:-}" && -f "$MANIFEST" ]] || die "no release manifest found in $RELEASE_DIR"

note "Using manifest: $MANIFEST"

TMP="$(mktemp -d)"
trap 'rm -rf "$TMP"' EXIT

cp -a "$MANIFEST" "$TMP/manifest.json"

python3 - "$TMP/manifest.json" <<'PY'
import json,sys
p=sys.argv[1]
m=json.load(open(p,'r',encoding='utf-8'))
# Ensure baseline fields exist for the validator
for k in ("release_id","bundle_path","bundle_sha256"):
    if k not in m:
        raise SystemExit(f"baseline missing {k}, cannot test signing invariants")
print("baseline ok")
PY

# Helper to write mutated variants
mutate() {
  local in="$1"
  local out="$2"
  python3 - "$in" "$out" <<'PY'
import json,sys,copy
inp, outp = sys.argv[1], sys.argv[2]
m=json.load(open(inp,'r',encoding='utf-8'))
m2=copy.deepcopy(m)

mode=os.environ.get("MUT_MODE","")
if mode=="ALG_ONLY":
    m2["signing_alg"]="rsa-sha256-b64"
elif mode=="BAD_FP":
    m2["signing_alg"]="rsa-sha256-b64"
    m2["signing_pub_fingerprint_sha256"]="abc123"  # invalid
    m2["manifest_sig_b64_path"]="manifest.sig.b64"
    m2["bundle_sig_b64_path"]="bundle.sig.b64"
elif mode=="BAD_PATH":
    m2["signing_alg"]="rsa-sha256-b64"
    m2["signing_pub_fingerprint_sha256"]="0"*64
    m2["manifest_sig_b64_path"]="../escape.sig.b64"  # invalid
    m2["bundle_sig_b64_path"]="bundle.sig.b64"
elif mode=="VALID":
    m2["signing_alg"]="rsa-sha256-b64"
    m2["signing_pub_fingerprint_sha256"]="0"*64
    m2["manifest_sig_b64_path"]="manifest.sig.b64"
    m2["bundle_sig_b64_path"]="bundle.sig.b64"
else:
    raise SystemExit("unknown MUT_MODE")
json.dump(m2, open(outp,'w',encoding='utf-8'), indent=2, sort_keys=True)
PY
}

expect_fail() {
  local file="$1"
  if runtime/bin/validate_manifest "$file" >/dev/null 2>&1; then
    die "Expected FAIL but got PASS for $file"
  fi
}

expect_pass() {
  local file="$1"
  runtime/bin/validate_manifest "$file" >/dev/null
}

# Case 1: partial signing fields -> fail
note "Case 1: ALG_ONLY -> must fail"
export MUT_MODE="ALG_ONLY"
mutate "$TMP/manifest.json" "$TMP/alg_only.json"
expect_fail "$TMP/alg_only.json"

# Case 2: bad fingerprint -> fail
note "Case 2: BAD_FP -> must fail"
export MUT_MODE="BAD_FP"
mutate "$TMP/manifest.json" "$TMP/bad_fp.json"
# create declared sig files so failure is only fingerprint
touch "$TMP/manifest.sig.b64" "$TMP/bundle.sig.b64"
expect_fail "$TMP/bad_fp.json"

# Case 3: bad path traversal -> fail
note "Case 3: BAD_PATH -> must fail"
export MUT_MODE="BAD_PATH"
mutate "$TMP/manifest.json" "$TMP/bad_path.json"
touch "$TMP/bundle.sig.b64"
expect_fail "$TMP/bad_path.json"

# Case 4: valid signing metadata + files -> pass
note "Case 4: VALID -> must pass"
export MUT_MODE="VALID"
mutate "$TMP/manifest.json" "$TMP/valid.json"
touch "$TMP/manifest.sig.b64" "$TMP/bundle.sig.b64"
expect_pass "$TMP/valid.json"

note "âœ… Phase 98 signing invariants test PASS"
